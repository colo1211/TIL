# ch 01. 알아두어야 할 자바스크립트

## 호출 스택

LIFO 구조(스택, 후입선출) 

- **동기적**

```jsx
// 함수 선언 
function first(){
	second();
	console.log('첫번째');
}
function second(){
	third();
	console.log('두번째'); 
}
function third(){
	console.log('세번째'); 
}
**first(); // 첫번째 함수 호출| '세번째 두번째 첫번째' 순으로 출력** 
```

→ 메모리에 순차적으로 

1. anonymous
2. first() 
3. second()
4. third() 순으로 쌓인다. 

→ 이를 꺼낼 때는 4→1 순으로 꺼내진다. 

**호출 스택**

- Anonymous은 가상의 전역 컨텍스트 (항상 있다고 생각하는 게 좋음)
- 함수 호출 순서대로 쌓이고, 가장 최근에 쌓인 순서대로 실행
- 실행이 종료되면 스택에서 빠진다. ( '}' 를 만나는 순간 스택에서 빠짐)
- Last In First Out (후입 선출) 구조 → **스택**

**호출스택 만으로는 자바스크립트의 모든 동작을 설명 할 수 없다.** 

---

## 이벤트 루프

- **비동기적**

```jsx
function run(){
	console.log('3초 후 실행');
}
console.log('시작'); 
setTimeout(run, 3000);// 비동기적
console.log('끝'); 
```

```jsx
function oneMore(){
	console.log('one More');
} 

function run(){
	console.log('run,run');
	setTimeout(()=>{
		console.log('wow');		
},0);
	new Promise((resolve)=> {
		resolve('hi'); 	
})
	.then(console.log);
oneMore(); 
}

setTimeout(run, 5000); 
```

**실행 결과** 

```
run,run 
one More
hi
wow
```


- 4개의 가상 공간이 있다고 생각 (**호출 스택, 백그라운드, 태스크 큐, 메모리**)
- **호출 스택**과 **백그라운드(c++로 구성)**는 동시에 실행된다.
- 시작할 때 항상 호출스택에는 anonymous 가 차게 된다.
- **프로미스는 내부 선언까지는 동기, then 부터는 비동기 → 백그라운드로 가게된다.**
- 동기를 먼저 실행 (runrun , one More)
- 비동기는 나중에 실행 | 백그라운드에 들어온 순서대로 하면 익명함수(wow)가 먼저 실행 되어야 하지만, **Promise가 새치기(우선순위가 더 먼저이다)를 해서 Promise를 먼저 출력하게 된다.**

> **Promise.then/catch  process.nextTick  2가지는 타이머보다 우선순위이다.**

---

## var , const, let

- **var** : 함수 스코프(함수 밖에서 사용 할 수 없다)

```jsx
function a(){
	var y=3; 
} 
console.log(y); **// 에러, var 는 함수를 빠져나오지 못한다.** 
```

- **const, let :** 블록 스코프(중괄호 밖에서 사용 할 수 없다)

```jsx
if (true) {
	const x=3;
} 
**console.log(x); // 에러, const와 let은 {} 중괄호(블럭)를 빠져 나오지 못한다.** 
```

 

> 최신 문법에서는 var을 사용하지 않고 const와 let을 사용한다.

**const(상수)   vs   let**

- const로 변수를 선언 하면 값을 이후에 못 바꿈

```jsx
const a= 3; 
a=5; // 에러

const b = {name : '김경원'};
b.name = '김재원';  // 가능 객체 속성 수정 

const c; //에러 
```

**암기 Tip : const로 선언한 변수의 바로 옆에 =을 직접적으로 붙이지 못한다. 나머지는 가능** 

- let은 변수 값을 바꿀 때 사용

```jsx
let c= 5;
c=3; 
c=10; 
```

> 생각보다 let을 쓸 일이 별로 없다. const로 선언하는 것을 습관화 들일 것

---

## 템플릿 문자열 (편의 기능)

```jsx
var won  = 10000; 
var result = '이 과자는' + won + '입니다.';
console.log(result); // 이 과자는10000원입니다. 

**const result = `이 과자는 ${won}입니다.`; // 변수를 ${}로 감싸준다.** 
```

- **$ {변수명} 을 적용하기 위해서는 ` (백틱)으로 문자열을 감싸준다.**

```jsx
function a(){
	console.log(a); 
}

a(); // 이전 함수호출 방법 
a`` // 최신 함수호출 방법 
```

---

### 객체 리터럴

: 코드의 단순화 가능 

**이전 버전**  

```jsx
var sayNode = function(){
	console.log('Node'); 
}

var es = 'ES'; 

var oldObject= {
	sayJS : function () {
		console.log('JS'); 
} 
	sayNode:sayNode
};

oldObject[es+6] = 'fantastic'; // 객체에 속성 추가 (es6에 'fantastic') 

oldObject.sayNode();  // Node
oldObject.sayJS();  // JS 
console.log(oldObject.es6); // fantastic   
```

**최신 버전**

```jsx
const sayNode = function(){
	console.log('Node'); 
}

const es = 'ES'; 

const newObject = {
	sayJS(){ // 1. 
		console.log('JS'); 
}
	sayNode, // 2. 
	[es+6] = 'fantastic'; // 3.  
} 

oldObject.sayNode();  // Node
oldObject.sayJS();  // JS 
console.log(oldObject.es6); // fantastic 
```

---

**달라진 점**

1. 함수를 sayJS = function (){ console.log('JS');}; → sayJS() {console.log('JS');}; 로 축약  
2. 같은 이름으로 선언한 변수를 객체 내에서 적용 할 수 있음 sayNode 하나 쓴 걸로 선언 완료 
3. 객체의 내부에서 속성명을 동적으로 생성할 수 있다. 

---

## 화살표 함수

: 화살표 함수는 기존 function 선언과 동일한 역할을 한다. 

**그러나,  this 가 다르다. 따라서 완전히 대체는 불가능하다.**   

**기존** 

```jsx
function 함수명(a,b) {
	return a+b; 
} 
```

**최신** 

- **중괄호 '{' 이후에 return 값     →**  ' **⇒** ' 로 대체 가능

```jsx
const 함수명 = (a,b) => {
	return a+b; 
} //1 

const 함수명 = (a,b) => a+b;//2

const 함수명 = (a,b) => (a+b);//3
 
function not1 (x) {
		return !x; 
} //1 

const not1 = (x) => (!x);//2  
```

**차이점**

둘이 동일한 역할을 하지만, 앞서 언급한 것과 같이 **this가 다르다.** 

**기존**

```jsx
var 객체1 = {
    name : 'zero',
    friends : ['nero','xero','hero'],
    get_f : function(){
        var that = this; // forEach문 들어가기 전 부모 this 를 저장하는 문장이다.  
        this.friends.forEach(function(friends){
            console.log(that.name, friends);
})
    }
}
```

: 기존의 this는 **내부 함수에서는 부모 객체에서와 다른 this**를 가지게 된다. forEach에서 반복되는 것들이 this가 될 것이다. 

**최신**

```jsx
const 객체2 = {
    name : 'zero',
    friends: ['nero','xero','hero'],
    get_f(){
        this.friends.forEach(friends=>{
            console.log(this.name, friends);
})
    }
}
```

: 최신 문법에서는 this가 내부에 있던 외부에 있던 서로 같은 this를 가지게 된다. forEach문 내에서의 this는 객체2를 가리킨다. **부모의 this**만을 가질 수 있다. 

> **this →**       **기존: 내부에서 새로 갖는다.               최신: 항상 부모를 가리킨다.**

**주의 할 점**

객체를 리턴 하는 경우

- 객체를 리턴 (축약 X)

```jsx
const obj = (x,y) => {
		return {x:x, y:y}; 
}	
```

- 객체를 리턴하는 경우는 소괄호가 필수다. (엔진이 구분을 못한다.)

```jsx
const obj = (x,y) => ({x,y});
```

---

## 비 구조화 할당 (구조 분해 할당)

→ 객체 혹은 배열로부터 속성이나 요소를 간편하게 꺼낼 수 있다. 

```jsx
const example = { 
		a: 123,
		b: {c:135, d:146}
}; // example 객체 선언 

// example 객체에서 변수를 꺼내 쓰려면? (기존) -> 복잡 
const a= example.a; 
const d= example.b.d;

// 비구조화 할당 
const {a,b:{c,d}} = example; // 객체와 동일한 key 구조를 선언-> 객체를 대입 
console.log(a); // 123
console.log(c); // 135
```

- 객체 혹은 배열과 동일한 구조를 선언해주고 객체 혹은 배열을 대입해준다.
- 기존과는 다르게 간편하게 변수를 꺼내 쓸 수 있다.

---

## 상속 (생활 코딩 추가 설명)


- 동일한 기능을 가진 상속은 사용 이유가 없다.
- 아래의 코드는 완전히 기능이 같은 객체를 상속 받은 것

```jsx
function Person (name) { // 부모
    this.name = name; 
}

Person.prototype.name = null;
Person.prototype.introduce = function(){
    return 'my name is' + this.name;
}

function Programmer(name){ // 자식 
    this.name = name; 
} 

**Programmer.prototype = new Person(); // Programmer 객체의 prototype에 Person 객체를 추가(상속)**  

var p1= new Programmer('김경원');
var p2 = new Person('김경원'); 

p1
//Programmer {name: "김경원"}
//name: "김경원"
//__proto__: Person

p2 
//Person {name: "김경원"}
//name: "김경원"
//__proto__:
//introduce: ƒ ()
//name: null
//constructor: ƒ Person(name)
//__proto__: Object
```

### 상속 기능 추가


```jsx
// 부모 객체 
function Person (name) { 
    this.name = name; 
} 
Person.prototype.name =null; 
Person.prototype.introduce = function(){
    return 'my Name is' + this.name; 
}
//자식 객체1 
function Programmer(name) {
    this.name = name; 
} 
//상속 작업 -> Person의 기능을 그대로 가져다 놓음
Programmer.prototype = new Person();
//기능 추가 -> Person 기능 뿐만 아니라 새로운 기능 추가 
Programmer.prototype.coding = function() { 
    return 'hello world'; 
}

//자식 객체2
function Designer (name){
    this.name = name; 
}  
// 상속 작업 -> Person의 기능을 그대로 가져다 놓음 
Designer.prototype= new Person();
// 기능 추가 -> Person 기능 뿐만 아니라 새로운 기능 추가 
Designer.prototype.draw = function () { 
    return 'beautiful world'; 
}

var 사람 = new Person('김경원'); 
var 프로그래머 = new Programmer('김경원'); 
var 디자이너 = new Designer('김경원'); 

사람.introduce();
//"my Name is김경원"
프로그래머.introduce();
//"my Name is김경원"
디자이너.introduce();
//"my Name is김경원"
프로그래머.coding();
//"hello world"
디자이너.draw();
//"beautiful world"
```

---

## prototype(원형)

→ 프로토타입을 통해 상속 기능을 제공 

```jsx
function Ultra(){};
Ultra.prototype.isTrue= true;

function Super(){};
Super.prototype = new Ultra();

function Sub() {}; 
Sub.prototype=new Super();

var 프로토체인 = new Sub();

console.log(프로토체인.isTrue);
// true 나올때 까지 거슬러 올라간다. 
```

**다양한 예시** 

```jsx
function Ultra(){};
Ultra.prototype.isTrue= true;

function Super(){};
var s = new Ultra();
s.isTrue = 5; 
Super.prototype =s;

function Sub() {}; 
Sub.prototype=new Super();

var 프로토체인 = new Sub();

console.log(프로토체인.isTrue);
// 5 나올때 까지 거슬러 올라간다. 
```

---

## 클래스

- 클래스 문법이 추가 되었지만 여전히 프로토 타입 기반으로 동작
- 프로토타입 기반 문법을 보기 좋게 클래스로 변환하였다고 생각하면 된다.

```jsx
// Human 클래스 생성
class Human{
		// 생성자 함수 
    constructor(type='human') {
        this.type = type;
    }
    // 클래스 함수 -> static 키워드로 전환 
    static isHuman(human){
        return human instanceof Human; 
    } 
		// 프로토타입 함수들: 어떤 클래스 소속인지 알기 쉽게함 
    breathe() {
        alert('haaaaam');
    }
}

// Zero 클래스에 Human 클래스를 상속 (extends) 
class Zero extends Human{
    constructor (type, firstname, lastname){
        super(type);
        this.firstname = firstname; 
        this.lastname = lastname; 
    }
    
    sayname(){    
        super.breathe(); // 부모 클래스 함수인 sayname
        alert(`${this.firstname} ${this.lastname}`);
    }
} 

const newZero = new Zero('human','Kim','KyungWon');

//newZero
//Zero {type: "human", firstname: "Kim", lastname: "KyungWon"}
//firstname: "Kim"
//lastname: "KyungWon"
//type: "human"
//__proto__: Human
```

### 1. constructor , 생성자

: class 내 , 객체를 생성하고 초기화를 하기 위한 특별한 메소드이다. 

 

### 2. static , 정적

: 클래스의 정적 메소드를 정의한다. 

ex) return human instanceof Human; 

```jsx
function C(){}; 
function D(){}; 

var 나 = new C(); 
나 instanceof D; // false;
나 instanceof C; // true;
```

### 3. 프로토타입 함수들 → 어떤 함수가 어떤 클래스에 정의되어 있는지 알기 쉬움

### 4. 상속 , extends

```jsx
**class Zero extends Human{** 
    constructor (type, firstname, lastname){
        super(type);
        this.firstname = firstname; 
        this.lastname = lastname; 
    }
    
    sayname(){    
        super.breathe(); // 부모 클래스 함수인 sayname
        alert(`${this.firstname} ${this.lastname}`);
    }
} 
```

: Zero 클래스는 Human 클래스의 상속을 받았다. 

**따라서, Zero 클래스를 통해 만들어진 객체들은 Human클래스도 활용 가능**

### 5. super

: super → 부모 클래스를 지칭할 때 쓰는 문법 

ex ) super.breathe(); → Human Class에서 선언했던 함수를 super를 통해서 사용 가능하다. 

---

## 프로미스

: 콜백 헬이라 불리는 지저분한 자바스크립트 코드의 해결책 

→ 내용이 실행은 되었지만 결과를 아직 반환하지 않은 객체 

- 성공시 → then을 붙이면 결과를 반환해준다.
- 실패시 → catch를 붙이면 결과를 반환해준다.

- **Resolve(성공리턴값) → then으로 연결**
- **Reject(실패리턴값) → catch로 연결**
- finally 부분은 무조건 실행된다.

```jsx
const condition = true; 
const 프로미스 = new Promise((resolve, reject) => {
    if (condition) {
        resolve('성공'); 
    }
    else {
        reject('실패'); 
    } 
}); 
**// 여기까진 동기로 실행**

**// 여기부터는 비동기로 실행**  
프로미스
    .then((message)=> { // 성공시 
        alert(message);
    }) 
    .catch((error)=> { // 실패시 
        console.error(error);
    })

```